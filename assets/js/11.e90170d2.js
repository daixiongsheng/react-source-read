(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{373:function(e,r,t){"use strict";t.r(r);var a=t(26),c=Object(a.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"react-core"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-core"}},[e._v("#")]),e._v(" React Core")]),e._v(" "),t("p",[e._v("React “Core” 中包含所有"),t("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/top-level-api.html#react",target:"_blank",rel:"noopener noreferrer"}},[e._v("全局 "),t("code",[e._v("React")]),e._v(" API"),t("OutboundLink")],1),e._v("，比如：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("React.createElement()")])]),e._v(" "),t("li",[t("code",[e._v("React.Component")])]),e._v(" "),t("li",[t("code",[e._v("React.Children")])])]),e._v(" "),t("p",[t("strong",[e._v("React 核心只包含定义组件必要的 API")]),e._v("。它不包含"),t("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/reconciliation.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("协调"),t("OutboundLink")],1),e._v("算法或者其他平台特定的代码。它同时适用于 React DOM 和 React Native 组件。")]),e._v(" "),t("p",[e._v("React 核心代码在源码的 "),t("a",{attrs:{href:"https://github.com/facebook/react/tree/master/packages/react",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("packages/react")]),t("OutboundLink")],1),e._v(" 目录中。在 npm 上发布为 "),t("a",{attrs:{href:"https://www.npmjs.com/package/react",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("react")]),t("OutboundLink")],1),e._v(" 包。相应的独立浏览器构建版本称为 "),t("code",[e._v("react.js")]),e._v("，它会导出一个称为 "),t("code",[e._v("React")]),e._v(" 的全局对象。")]),e._v(" "),t("h3",{attrs:{id:""}},[t("a",{staticClass:"header-anchor",attrs:{href:"#"}},[e._v("#")])]),e._v(" "),t("h3",{attrs:{id:"渲染器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#渲染器"}},[e._v("#")]),e._v(" 渲染器")]),e._v(" "),t("p",[e._v("React 最初只是服务于 DOM，但是这之后被改编成也能同时支持原生平台的 "),t("a",{attrs:{href:"https://reactnative.dev/",target:"_blank",rel:"noopener noreferrer"}},[e._v("React Native"),t("OutboundLink")],1),e._v("。因此，在 React 内部机制中引入了“渲染器”这个概念。")]),e._v(" "),t("p",[t("strong",[e._v("渲染器用于管理一棵 React 树，使其根据底层平台进行不同的调用。")])]),e._v(" "),t("p",[e._v("渲染器同样位于 "),t("a",{attrs:{href:"https://github.com/facebook/react/tree/master/packages/",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("packages/")]),t("OutboundLink")],1),e._v(" 目录下：")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://github.com/facebook/react/tree/master/packages/react-dom",target:"_blank",rel:"noopener noreferrer"}},[e._v("React DOM Renderer"),t("OutboundLink")],1),e._v(" 将 React 组件渲染成 DOM。它实现了全局 "),t("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/react-dom.html",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("ReactDOM")]),e._v("API"),t("OutboundLink")],1),e._v("，这在 npm 上作为 "),t("a",{attrs:{href:"https://www.npmjs.com/package/react-dom",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("react-dom")]),t("OutboundLink")],1),e._v(" 包。这也可以作为单独浏览器版本使用，称为 "),t("code",[e._v("react-dom.js")]),e._v("，导出一个 "),t("code",[e._v("ReactDOM")]),e._v(" 的全局对象.")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/facebook/react/tree/master/packages/react-native-renderer",target:"_blank",rel:"noopener noreferrer"}},[e._v("React Native Renderer"),t("OutboundLink")],1),e._v(" 将 React 组件渲染为 Native 视图。此渲染器在 React Native 内部使用。")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/facebook/react/tree/master/packages/react-test-renderer",target:"_blank",rel:"noopener noreferrer"}},[e._v("React Test Renderer"),t("OutboundLink")],1),e._v(" 将 React 组件渲染为 JSON 树。这用于 "),t("a",{attrs:{href:"https://facebook.github.io/jest",target:"_blank",rel:"noopener noreferrer"}},[e._v("Jest"),t("OutboundLink")],1),e._v(" 的"),t("a",{attrs:{href:"https://facebook.github.io/jest/blog/2016/07/27/jest-14.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("快照测试"),t("OutboundLink")],1),e._v("特性。在 npm 上作为 "),t("a",{attrs:{href:"https://www.npmjs.com/package/react-test-renderer",target:"_blank",rel:"noopener noreferrer"}},[e._v("react-test-renderer"),t("OutboundLink")],1),e._v(" 包发布。")])]),e._v(" "),t("p",[e._v("另外一个官方支持的渲染器的是 "),t("a",{attrs:{href:"https://github.com/facebook/react/tree/master/packages/react-art",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("react-art")]),t("OutboundLink")],1),e._v("。它曾经是一个独立的 "),t("a",{attrs:{href:"https://github.com/reactjs/react-art",target:"_blank",rel:"noopener noreferrer"}},[e._v("GitHub 仓库"),t("OutboundLink")],1),e._v("，但是现在我们将此加入了主源代码树。")]),e._v(" "),t("h3",{attrs:{id:"reconcilers"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reconcilers"}},[e._v("#")]),e._v(" reconcilers")]),e._v(" "),t("p",[e._v("即便 React DOM 和 React Native 渲染器的区别很大，但也需要共享一些逻辑。特别是"),t("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/reconciliation.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("协调"),t("OutboundLink")],1),e._v("算法需要尽可能相似，这样可以让声明式渲染，自定义组件，state，生命周期方法和 refs 等特性，保持跨平台工作一致。")]),e._v(" "),t("p",[e._v("为了解决这个问题，不同的渲染器彼此共享一些代码。我们称 React 的这一部分为 “reconciler”。当处理类似于 "),t("code",[e._v("setState()")]),e._v(" 这样的更新时，reconciler 会调用树中组件上的 "),t("code",[e._v("render()")]),e._v("，然后决定是否进行挂载，更新或是卸载操作。")]),e._v(" "),t("p",[e._v("Reconciler 没有单独的包，因为他们暂时没有公共 API。相反，它们被如 React DOM 和 React Native 的渲染器排除在外。")]),e._v(" "),t("h3",{attrs:{id:"fiber-reconciler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fiber-reconciler"}},[e._v("#")]),e._v(" Fiber reconciler")]),e._v(" "),t("p",[e._v("“fiber” reconciler 是一个新尝试，致力于解决 stack reconciler 中固有的问题，同时解决一些历史遗留问题。Fiber 从 React 16 开始变成了默认的 reconciler。")]),e._v(" "),t("p",[e._v("它的主要目标是：")]),e._v(" "),t("ul",[t("li",[e._v("能够把可中断的任务切片处理。")]),e._v(" "),t("li",[e._v("能够调整优先级，重置并复用任务。")]),e._v(" "),t("li",[e._v("能够在父元素与子元素之间交错处理，以支持 React 中的布局。")]),e._v(" "),t("li",[e._v("能够在 "),t("code",[e._v("render()")]),e._v(" 中返回多个元素。")]),e._v(" "),t("li",[e._v("更好地支持错误边界。")])]),e._v(" "),t("h3",{attrs:{id:"-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#-2"}},[e._v("#")])]),e._v(" "),t("h3",{attrs:{id:"挂载是递归过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#挂载是递归过程"}},[e._v("#")]),e._v(" 挂载是递归过程")]),e._v(" "),t("p",[e._v("reconciler 检查 "),t("code",[e._v("App")]),e._v(" 是一个类还是一个函数。")]),e._v(" "),t("p",[e._v("如果 "),t("code",[e._v("App")]),e._v(" 是函数，那么 reconciler 会调用 "),t("code",[e._v("App(props)")]),e._v(" 来获取渲染的元素。")]),e._v(" "),t("p",[e._v("如果 "),t("code",[e._v("App")]),e._v(" 是类，那么 reconciler 会通过 "),t("code",[e._v("new App(props)")]),e._v(" 来实例化 "),t("code",[e._v("App")]),e._v("，并调用生命周期方法 "),t("code",[e._v("componentWillMount()")]),e._v("，之后调用 "),t("code",[e._v("render()")]),e._v(" 方法来获取渲染的元素。")]),e._v(" "),t("p",[e._v("无论哪种方式，reconciler 都会探悉 "),t("code",[e._v("App")]),e._v(" 的内容并渲染。")]),e._v(" "),t("p",[e._v("这个过程是递归的。"),t("code",[e._v("App")]),e._v(" 可能会渲染某个 "),t("code",[e._v("<Greeting />")]),e._v("，"),t("code",[e._v("Greeting")]),e._v(" 可能会渲染某个 "),t("code",[e._v("<Button />")]),e._v("，以此类推。当它探悉各个组件渲染的元素时，reconciler 会通过用户定义的组件递归地 “向下探索”。")]),e._v(" "),t("p",[t("strong",[e._v("注意：")])]),e._v(" "),t("p",[e._v("reconciler 本身不与 DOM 绑定。挂载的确切结果（在源代码中有时叫做 “挂载映像”）取决于 renderer，可以是一个 DOM 节点（React DOM），一个字符串（React DOM Server），或是一个表示原生视图的数字（React Native）。")]),e._v(" "),t("h3",{attrs:{id:"事件系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件系统"}},[e._v("#")]),e._v(" 事件系统")]),e._v(" "),t("p",[e._v("React 在原生事件基础上进行了封装，以抹平浏览器间差异。其源码在 "),t("a",{attrs:{href:"https://github.com/facebook/react/tree/master/packages/react-dom/src/events",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("packages/react-dom/src/events")]),t("OutboundLink")],1),e._v(" 目录下。")]),e._v(" "),t("h3",{attrs:{id:"-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#-3"}},[e._v("#")])])])}),[],!1,null,null,null);r.default=c.exports}}]);